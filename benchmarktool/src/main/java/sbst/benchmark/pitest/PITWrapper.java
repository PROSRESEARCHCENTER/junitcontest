package sbst.benchmark.pitest;

import org.pitest.classinfo.ClassByteArraySource;
import org.pitest.classinfo.ClassName;
import org.pitest.classpath.ClassloaderByteArraySource;
import org.pitest.functional.prelude.Prelude;
import org.pitest.mutationtest.commandline.OptionsParser;
import org.pitest.mutationtest.commandline.ParseResult;
import org.pitest.mutationtest.commandline.PluginFilter;
import org.pitest.mutationtest.config.PluginServices;
import org.pitest.mutationtest.config.ReportOptions;
import org.pitest.mutationtest.engine.Mutater;
import org.pitest.mutationtest.engine.MutationDetails;
import org.pitest.mutationtest.engine.MutationEngine;
import org.pitest.mutationtest.engine.MutationIdentifier;
import org.pitest.mutationtest.engine.gregor.config.GregorEngineFactory;
import sbst.benchmark.coverage.TestUtil;

import java.io.IOException;
import java.net.URL;
import java.net.URLClassLoader;
import java.util.List;

/**
 * This class implement a small wrapper for PIT. Upon the execution of its constructor, it will provide
 * all the mutations generated by PIT
 *
 * @author annibale.panichella
 */
public class PITWrapper {

    /**
     * Data structure to keep of the generated mutations
     **/
    private MutationSet generatedMutants;

    /**
     * This constructor invokes the mutation generation engine available from PIT. It works as follows:
     * 1) it uses the input parameters to generated the standard PIT configuration <br>
     * 2) it calls the mutation generation engine available from PIT
     * 3) it loads all required classes at run-time
     * 4) it stores the generated mutations in the attributes
     *
     * @param pClassPath     class path with all required libraries (compiles SUT, compiled generated tests, etc.)
     * @param pClassToMutate Class Under Test (i.e., to mutate) including packages names
     * @param pTargetTest    generate tests to execute against the mutations
     */
    public PITWrapper(String pClassPath, String pClassToMutate, List<String> pTargetTest) {
        // convert the list of tests in the right format required by PIT
        // This is expressed as a comma separated list of string (test names)
        String testList = pTargetTest.get(0);
        for (int index = 1; index < pTargetTest.size(); index++) {
            testList = testList + "," + pTargetTest.get(index);
        }

        // create the arguments for PIT's option parser
        String[] args4Pit = {
                "--classPath",
                pClassPath,
                "--targetClasses",
                pClassToMutate,
                "--targetTests",
                testList};

        PluginServices plugins = new PluginServices(this.getClass().getClassLoader());
        OptionsParser parser = new OptionsParser(new PluginFilter(plugins));
        ParseResult pr = parser.parse(args4Pit);
        ReportOptions options = pr.getOptions(); // get the options for PIT

        // Call the mutant generation engine from PIT
        GregorEngineFactory fact = new GregorEngineFactory();
        MutationEngine engine = fact.createEngine(options.isMutateStaticInitializers(),
                Prelude.or(options.getExcludedMethods()),
                options.getLoggingClasses(),
                options.getMutators(),
                options.isDetectInlinedCode());

        try {
            // load required classes at runtime
            URL[] urls = TestUtil.createURLs(pClassPath);
            URLClassLoader cl = URLClassLoader.newInstance(urls, this.getClass().getClassLoader());

            // load at runtime the class to mutate
            ClassByteArraySource byteSource = new ClassloaderByteArraySource(cl);
            Mutater mutater = engine.createMutator(byteSource);

            ClassName classToMutate = new ClassName(pClassToMutate);

            // generate all possible mutants for the class under test
            List<MutationDetails> list = mutater.findMutations(classToMutate);
            generatedMutants = new MutationSet();

            int count = 0;
            for (MutationDetails mutantDetail : list) {
                count++;
                if (list.size() > 400) {
                    if ((count % 3) > 0) {
                        //Main.info("Mutation skipped " +mutantDetail.getId());
                        continue;
                    }
                } else if (list.size() > 200) {
                    if ((count % 2) == 0) {
                        //Main.info("Mutation skipped " +mutantDetail.getId());
                        continue;
                    }
                }

                //Main.info("Mutation taken " +mutantDetail.getId());

                MutationIdentifier id = mutantDetail.getId();
                generatedMutants.addMutant(id, mutater.getMutation(id), mutantDetail);
            }

            //close class loader
            cl.close();
        } catch (IOException e) {
            // TODO Auto-generated catch block
            e.printStackTrace();
        }
    }

    public MutationSet getGeneratedMutants() {
        return generatedMutants;
    }

}
